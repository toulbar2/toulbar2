

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modules &mdash; toulbar2 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/toulbar2.css?v=4cefacce" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Libraries" href="ref_lib.html" />
    <link rel="prev" title="Exact optimization for cost function networks and additive graphical models" href="../_files/README.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            toulbar2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../presentation.html">Presentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../downloads.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmark libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/usecases.html">Use cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userdoc.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../refman.html">Reference Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ref_intro.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_files/README.html">Exact optimization for cost function networks and additive graphical models</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-and-cost-function-modeling">Variable and cost function modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solving-cost-function-networks">Solving cost function networks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output-messages-verbosity-options-and-debugging">Output messages, verbosity options and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preprocessing-techniques">Preprocessing techniques</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-and-value-search-ordering-heuristics">Variable and value search ordering heuristics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#soft-arc-consistency-and-problem-reformulation">Soft arc consistency and problem reformulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#virtual-arc-consistency-enforcing">Virtual Arc Consistency enforcing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nc-bucket-sort">NC bucket sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-elimination">Variable elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#propagation-loop">Propagation loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#backtrack-management">Backtrack management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ref_lib.html">Libraries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pdfmanuals.html">Documentation in pdf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">toulbar2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          
<div class=toulbar2header>

  <div class="toulbar2logo">

    <h1>toulbar2</h1>
    <h2>An exact solver for cost function networks</h2>

  </div>

  <div class=toulbar2headerline>

    <a href=../presentation.html>Presentation</a> |
    <a href=../downloads.html>Downloads</a> |
    <a href=../benchmarks.html>Benchmarks</a> |
    <a href=../examples/tutorials.html>Tutorials</a> |
    <a href=../examples/usecases.html>Use cases</a> |
    <a href=../userdoc.html>User</a> |
    <a href=../refman.html>Reference</a> |
    <a href=../pdfmanuals.html>Doc in pdf</a> |
    <a href=../publications.html>Publications</a>

  </div>

</div>

<!-- News : see news_*.rst pages -->

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modules">
<span id="ref-modules"></span><h1>Modules<a class="headerlink" href="#modules" title="Link to this heading"></a></h1>
<section id="variable-and-cost-function-modeling">
<h2>Variable and cost function modeling<a class="headerlink" href="#variable-and-cost-function-modeling" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__modeling"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Variable</span> <span class="pre">and</span> <span class="pre">cost</span> <span class="pre">function</span> <span class="pre">modeling</span></span></dt>
<dd><p><p>Modeling a Weighted CSP consists in creating variables and cost functions.</p>
<p>Domains of variables can be of two different types:</p>
<ul class="simple">
<li><p>enumerated domain allowing direct access to each value (array) and iteration on current domain in times proportional to the current number of values (double-linked list)</p></li>
<li><p>interval domain represented by a lower value and an upper value only (useful for large domains)</p></li>
</ul>

Warning : Current implementation of toulbar2 has limited modeling and solving facilities for interval domains. There is no cost functions accepting both interval and enumerated variables for the moment, which means all the variables should have the same type.</p>
<p><p>Cost functions can be defined in extension (table or maps) or having a specific semantic.</p>
<p>Cost functions in extension depend on their arity:</p>
<ul class="simple">
<li><p>unary cost function (directly associated to an enumerated variable)</p></li>
<li><p>binary and ternary cost functions (table of costs)</p></li>
<li><p>n-ary cost functions (n &gt;= 4) defined by a list of tuples with associated costs and a default cost for missing tuples (allows for a compact representation)</p></li>
</ul>

Cost functions having a specific semantic (see <a class="reference internal" href="../formats/wcspformat.html#group__wcspformat"><span class="std std-ref">Weighted Constraint Satisfaction Problem file format (wcsp)</span></a>) are:<ul class="simple">
<li><p>simple arithmetic and scheduling (temporal disjunction) cost functions on interval variables</p></li>
<li><p>global cost functions (<em>eg</em> soft alldifferent, soft global cardinality constraint, soft same, soft regular, etc) with three different propagator keywords:<ul>
<li><p><em>flow</em> propagator based on flow algorithms with “s” prefix in the keyword (<em>salldiff</em>, <em>sgcc</em>, <em>ssame</em>, <em>sregular</em>)</p></li>
<li><p><em>DAG</em> propagator based on dynamic programming algorithms with “s” prefix and “dp” postfix (<em>samongdp</em>, salldiffdp, sgccdp, sregulardp, sgrammardp, smstdp, smaxdp)</p></li>
<li><p><em>network</em> propagator based on cost function network decomposition with “w” prefix (<em>wsum</em>, <em>wvarsum</em>, <em>walldiff</em>, <em>wgcc</em>, <em>wsame</em>, <em>wsamegcc</em>, <em>wregular</em>, <em>wamong</em>, <em>wvaramong</em>, <em>woverlap</em>)</p></li>
</ul>
</p></li>
</ul>

Note : The default semantics (using <em>var</em> keyword) of monolithic (flow and DAG-based propagators) global cost functions is to count the number of variables to change in order to restore consistency and to multiply it by the basecost. Other particular semantics may be used in conjunction with the flow-based propagator</p>
<p>Note : The semantics of the network-based propagator approach is either a hard constraint (“hard” keyword) or a soft constraint by multiplying the number of changes by the basecost (“lin” or “var” keyword) or by multiplying the square value of the number of changes by the basecost (“quad” keyword)</p>
<p>Note : A decomposable version exists for each monolithic global cost function, except grammar and MST. The decomposable ones may propagate less than their monolithic counterpart and they introduce extra variables but they can be much faster in practice</p>
<p>Warning : Each global cost function may have less than three propagators implemented</p>
<p>Warning : Current implementation of toulbar2 has limited solving facilities for monolithic global cost functions (no BTD-like methods nor variable elimination)</p>
<p>Warning : Current implementation of toulbar2 disallows global cost functions with less than or equal to three variables in their scope (use cost functions in extension instead)</p>
<p>Warning : Before modeling the problem using make and post, call ::tb2init method to initialize toulbar2 global variables</p>
<p>Warning : After modeling the problem using make and post, call <a class="reference internal" href="ref_cpp.html#classWeightedCSP_1a31a9384d3dabf5388fe610710f2f19e0"><span class="std std-ref">WeightedCSP::sortConstraints</span></a> method to initialize correctly the model before solving it </p>
</dd></dl>

</section>
<section id="solving-cost-function-networks">
<h2>Solving cost function networks<a class="headerlink" href="#solving-cost-function-networks" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__solving"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Solving</span> <span class="pre">cost</span> <span class="pre">function</span> <span class="pre">networks</span></span></dt>
<dd><p>After creating a Weighted CSP, it can be solved using a local search method like INCOP or PILS (see <a class="reference internal" href="ref_cpp.html#classWeightedCSPSolver_1af481cf37ff94238ab1e15bff34026209"><span class="std std-ref">WeightedCSPSolver::narycsp</span></a> or <a class="reference internal" href="ref_cpp.html#classWeightedCSPSolver_1a94898d20bff27abdb156ed2e248a8004"><span class="std std-ref">WeightedCSPSolver::pils</span></a>) and/or an exact search method (see <a class="reference internal" href="ref_cpp.html#classWeightedCSPSolver_1ab1f9d2c018bf050a6b010680a2008171"><span class="std std-ref">WeightedCSPSolver::solve</span></a>).</p>
<p><p>Various options of the solving methods are controlled by ::Toulbar2 static class members (see files ./src/core/tb2types.hpp and ./src/tb2main.cpp).</p>
<p>A brief code example reading a wcsp problem given as a single command-line parameter and solving it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &quot;toulbar2lib.hpp&quot;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
int main(int argc, char **argv) {

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

    // Create a solver object
    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data-type
    WeightedCSPSolver *solver = WeightedCSPSolver::makeWeightedCSPSolver(MAX_COST);

    // Read a problem file in wcsp format
    solver-&gt;read_wcsp(argv[1]);

    ToulBar2::verbose = -1;  // change to 0 or higher values to see more trace information

    // Uncomment if solved using INCOP local search followed by a partial Limited Discrepancy Search with a maximum discrepancy of one
    //  ToulBar2::incop_cmd = &quot;0 1 3 idwa 100000 cv v 0 200 1 0 0&quot;;
    //  ToulBar2::lds = -1;  // remove it or change to a positive value then the search continues by a complete B&amp;B search method
    // Uncomment the following lines if solved using Decomposition Guided Variable Neighborhood Search with min-fill cluster decomposition and absorption
    // ToulBar2::lds = 4;
    // ToulBar2::restart = 10000;
    // ToulBar2::searchMethod = DGVNS;
    // ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    // ToulBar2::boostingBTD = 0.7;
    // ToulBar2::varOrder = reinterpret_cast&lt;char*&gt;(-3);

    if (solver-&gt;solve()) {
        // show (sub-)optimal solution
        vector&lt;Value&gt; sol;
        Cost ub = solver-&gt;getSolution(sol);
        cout &lt;&lt; &quot;Best solution found cost: &quot; &lt;&lt; ub &lt;&lt; endl;
        cout &lt;&lt; &quot;Best solution found:&quot;;
        for (unsigned int i=0; i&lt;sol.size(); i++) cout &lt;&lt; ((i&gt;0)?&quot;,&quot;:&quot;&quot;) &lt;&lt; &quot; x&quot; &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; sol[i];
        cout &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;No solution found!&quot; &lt;&lt; endl;
    }
    delete solver;
}
</pre></div>
</div>
</p>
<p>See : another code example in ./src/toulbar2test.cpp</p>
<p>Warning : variable domains must start at zero, otherwise recompile libtb2.so without flag WCSPFORMATONLY </p>
</dd></dl>

<p><strong>toulbar2test.cpp</strong></p>
<blockquote>
<div><p><a class="reference download internal" download="" href="../_downloads/af18470515498cdbc4f5e516f6664a2b/toulbar2test.cpp"><code class="xref download docutils literal notranslate"><span class="pre">toulbar2test.cpp</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
/**
 * Test toulbar2 API
 *
 * warning: compile with the same compilation flags as for creating libtb2.so
 * e.g., g++ -DBOOST -DLONGDOUBLE_PROB -DLONGLONG_COST -I./src -o sudoku sudoku_tutorial.cpp -L./build/lib/Linux -ltb2
 */

#include &quot;toulbar2lib.hpp&quot;

#include &quot;core/tb2wcsp.hpp&quot;
#include &quot;vns/tb2vnsutils.hpp&quot;
#include &quot;vns/tb2dgvns.hpp&quot;
#ifdef OPENMPI
#include &quot;vns/tb2cpdgvns.hpp&quot;
#include &quot;vns/tb2rpdgvns.hpp&quot;
#endif
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

// INCOP default command line option
const string Incop_cmd = &quot;0 1 3 idwa 100000 cv v 0 200 1 0 0&quot;;

int main(int argc, char* argv[])
{
#ifdef OPENMPI
    mpi::environment env; // equivalent to MPI_Init via the constructor and MPI_finalize via the destructor
    mpi::communicator world;
#endif

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

#ifdef OPENMPI
    if (world.rank() == WeightedCSPSolver::MASTER)
        ToulBar2::verbose = -1; // change to 0 or higher values to see more trace information
    else
        ToulBar2::verbose = -1;
#else
    ToulBar2::verbose = -1; // change to 0 or higher values to see more trace information
#endif

    // uncomment if Virtual Arc Consistency (equivalent to Augmented DAG algorithm) enable
    //	ToulBar2::vac = 1; // option -A
    //	ToulBar2::vacValueHeuristic = VAC_SUPPORT_HEUR; // option -V
    // uncomment if partial Limited Discrepancy Search enable
    //	ToulBar2::lds = 1;  // option -l=1
    // uncomment if INCOP local search enable
    //	ToulBar2::incop_cmd = Incop_cmd; // option -i
    // uncomment the following lines if variable neighborhood search enable
    // ToulBar2::lds = 4;
    // ToulBar2::restart = 10000;
    // #ifdef OPENMPI
    //     if (world.size() &gt; 1) {
    //    	 ToulBar2::searchMethod = RPDGVNS;
    //    	 ToulBar2::vnsParallel = true;
    //    	 ToulBar2::vnsNeighborVarHeur = MASTERCLUSTERRAND;
    //    	 ToulBar2::vnsParallelSync = false;
    //     } else {
    //    	 ToulBar2::searchMethod = DGVNS;
    //    	 ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    //     }
    // #else
    //	ToulBar2::searchMethod = DGVNS;
    //	ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    //**or**
    //  ToulBar2::searchMethod = VNS;
    //  ToulBar2::vnsNeighborVarHeur = RANDOMVAR;
    // #endif

    // create a problem with three 0/1 variables
    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data-type
    WeightedCSPSolver* solver = WeightedCSPSolver::makeWeightedCSPSolver(MAX_COST);
    int x = solver-&gt;getWCSP()-&gt;makeEnumeratedVariable(&quot;x&quot;, 0, 1); // note that for efficiency issue, I assume domain values start at zero (otherwise remove flag -DWCSPFORMATONLY in Makefile)
    int y = solver-&gt;getWCSP()-&gt;makeEnumeratedVariable(&quot;y&quot;, 0, 1);
    int z = solver-&gt;getWCSP()-&gt;makeEnumeratedVariable(&quot;z&quot;, 0, 1);

    // add random unary cost functions on each variable
    mysrand(getpid());
    {
        vector&lt;Cost&gt; costs(2, 0);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver-&gt;getWCSP()-&gt;postUnary(x, costs);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver-&gt;getWCSP()-&gt;postUnary(y, costs);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver-&gt;getWCSP()-&gt;postUnary(z, costs);
    }

    // add binary cost functions (Ising) on each pair of variables
    {
        vector&lt;Cost&gt; costs;
        for (unsigned int i = 0; i &lt; 2; i++) {
            for (unsigned int j = 0; j &lt; 2; j++) {
                costs.push_back((solver-&gt;getWCSP()-&gt;toValue(x, i) == solver-&gt;getWCSP()-&gt;toValue(y, j)) ? 0 : 30); // penalizes by a cost=30 if variables are assigned to different values
            }
        }
        solver-&gt;getWCSP()-&gt;postBinaryConstraint(x, y, costs);
        solver-&gt;getWCSP()-&gt;postBinaryConstraint(x, z, costs);
        solver-&gt;getWCSP()-&gt;postBinaryConstraint(y, z, costs);
    }

    // add a ternary hard constraint (x+y=z)
    {
        vector&lt;Cost&gt; costs;
        for (unsigned int i = 0; i &lt; 2; i++) {
            for (unsigned int j = 0; j &lt; 2; j++) {
                for (unsigned int k = 0; k &lt; 2; k++) {
                    costs.push_back((solver-&gt;getWCSP()-&gt;toValue(x, i) + solver-&gt;getWCSP()-&gt;toValue(y, j) == solver-&gt;getWCSP()-&gt;toValue(z, k)) ? 0 : MAX_COST);
                }
            }
        }
        solver-&gt;getWCSP()-&gt;postTernaryConstraint(x, y, z, costs);
    }

    solver-&gt;getWCSP()-&gt;sortConstraints(); // must be done before the search

    //	int verbose = ToulBar2::verbose;
    //	ToulBar2::verbose = 5;  // high verbosity to see the cost functions
    //	solver-&gt;getWCSP()-&gt;print(cout);
    //	ToulBar2::verbose = verbose;

    // tb2checkOptions();
    if (solver-&gt;solve()) {
#ifdef OPENMPI
        if (world.rank() == WeightedCSPSolver::MASTER) {
#endif
            // show optimal solution
            vector&lt;Value&gt; sol;
            Cost optimum = solver-&gt;getSolution(sol);
            cout &lt;&lt; &quot;Optimum=&quot; &lt;&lt; optimum &lt;&lt; endl;
            cout &lt;&lt; &quot;Solution: x=&quot; &lt;&lt; sol[x] &lt;&lt; &quot; ,y=&quot; &lt;&lt; sol[y] &lt;&lt; &quot; ,z=&quot; &lt;&lt; sol[z] &lt;&lt; endl;
#ifdef OPENMPI
        }
#endif
    } else {
#ifdef OPENMPI
        if (world.rank() == WeightedCSPSolver::MASTER) {
#endif
            cout &lt;&lt; &quot;No solution found!&quot; &lt;&lt; endl;
#ifdef OPENMPI
        }
#endif
    }
    // cout &lt;&lt; &quot;Problem lower bound: &quot; &lt;&lt; solver-&gt;getWCSP()-&gt;getLb() &lt;&lt; endl; // initial problem lower bound possibly enhanced by value removals at the root during search

    delete solver;
    return 0;
}

/* Local Variables: */
/* c-basic-offset: 4 */
/* tab-width: 4 */
/* indent-tabs-mode: nil */
/* c-default-style: &quot;k&amp;r&quot; */
/* End: */
</pre></div>
</div>
</div></blockquote>
</section>
<section id="output-messages-verbosity-options-and-debugging">
<h2>Output messages, verbosity options and debugging<a class="headerlink" href="#output-messages-verbosity-options-and-debugging" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__verbosity"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Output</span> <span class="pre">messages,</span> <span class="pre">verbosity</span> <span class="pre">options</span> <span class="pre">and</span> <span class="pre">debugging</span></span></dt>
<dd><p>Depending on verbosity level given as option “-v=level”, <code class="docutils literal notranslate"><span class="pre">toulbar2</span></code> will output:<ul class="simple">
<li><p>(level=0, no verbosity) default output mode: shows version number, number of variables and cost functions read in the problem file, number of unassigned variables and cost functions after preprocessing, problem upper and lower bounds after preprocessing. Outputs current best solution cost found, ends by giving the optimum or “No solution”. Last output line should always be: “end.”</p></li>
<li><p>(level=-1, no verbosity) restricted output mode: do not print current best solution cost found</p></li>
</ul>
<ol class="arabic simple">
<li><p>(level=1) shows also search choices (“[”<em>search_depth</em> <em>problem_lower_bound</em> <em>problem_upper_bound</em> <em>sum_of_current_domain_sizes”] Try”</em> <em>variable_index</em> <em>operator</em> <em>value</em>) with <em>operator</em> being assignment (“==”), value removal (“!=”), domain splitting (“&lt;=” or “&gt;=”, also showing EAC value in parenthesis)</p></li>
<li><p>(level=2) shows also current domains (<em>variable_index</em> <em>list_of_current_domain_values</em> “/” <em>number_of_cost_functions</em> (see approximate degree in <a class="reference internal" href="#group__varelim"><span class="std std-ref">Variable elimination</span></a>) “/” <em>weighted_degree</em> <em>list_of_unary_costs</em> “s:” <em>support_value</em>) before each search choice and reports problem lower bound increases, NC bucket sort data (see <a class="reference internal" href="#group__ncbucket"><span class="std std-ref">NC bucket sort</span></a>), and basic operations on domains of variables</p></li>
<li><p>(level=3) reports also basic arc EPT operations on cost functions (see <a class="reference internal" href="#group__softac"><span class="std std-ref">Soft arc consistency and problem reformulation</span></a>)</p></li>
<li><p>(level=4) shows also current list of cost functions for each variable and reports more details on arc EPT operations (showing all changes in cost functions)</p></li>
<li><p>(level=5) reports more details on cost functions defined in extension giving their content (cost table by first increasing values in the current domain of the last variable in the scope)</p></li>
</ol>
</p>
<p>For debugging purposes, another option “-Z=level” allows one to monitor the search:<ol class="arabic simple">
<li><p>(level 1) shows current search depth (number of search choices from the root of the search tree) and reports statistics on nogoods for BTD-like methods</p></li>
<li><p>(level 2) idem</p></li>
<li><p>(level 3) also saves current problem into a file before each search choice</p></li>
</ol>
</p>
<p>Note : <code class="docutils literal notranslate"><span class="pre">toulbar2</span></code>, compiled in debug mode, can be more verbose and it checks a lot of assertions (pre/post conditions in the code)</p>
<p>Note : <code class="docutils literal notranslate"><span class="pre">toulbar2</span></code> will output an help message giving available options if run without any parameters </p>
</dd></dl>

</section>
<section id="preprocessing-techniques">
<h2>Preprocessing techniques<a class="headerlink" href="#preprocessing-techniques" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__preprocessing"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Preprocessing</span> <span class="pre">techniques</span></span></dt>
<dd><p>Depending on toulbar2 options, the sequence of preprocessing techniques applied before the search is:<ol class="arabic simple">
<li><p><em>i-bounded</em> variable elimination with user-defined <em>i</em> bound</p></li>
<li><p>pairwise decomposition of cost functions (binary cost functions are implicitly decomposed by soft AC and empty cost function removals)</p></li>
<li><p>MinSumDiffusion propagation (see VAC)</p></li>
<li><p>projects&amp;substracts n-ary cost functions in extension on all the binary cost functions inside their scope (3 &lt; n &lt; max, see toulbar2 options)</p></li>
<li><p>functional variable elimination (see <a class="reference internal" href="#group__varelim"><span class="std std-ref">Variable elimination</span></a>)</p></li>
<li><p>projects&amp;substracts ternary cost functions in extension on their three binary cost functions inside their scope (before that, extends the existing binary cost functions to the ternary cost function and applies pairwise decomposition)</p></li>
<li><p>creates new ternary cost functions for all triangles (<em>ie</em> occurences of three binary cost functions <em>xy</em>, <em>yz</em>, <em>zx</em>)</p></li>
<li><p>removes empty cost functions while repeating #1 and #2 until no new cost functions can be removed</p></li>
</ol>
</p>
<p>Note : the propagation loop is called after each preprocessing technique (see WCSP::propagate) </p>
</dd></dl>

</section>
<section id="variable-and-value-search-ordering-heuristics">
<h2>Variable and value search ordering heuristics<a class="headerlink" href="#variable-and-value-search-ordering-heuristics" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__heuristics"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Variable</span> <span class="pre">and</span> <span class="pre">value</span> <span class="pre">search</span> <span class="pre">ordering</span> <span class="pre">heuristics</span></span></dt>
<dd><p>See : <em> Boosting Systematic Search by Weighting Constraints </em>. Frederic Boussemart, Fred Hemery, Christophe Lecoutre, Lakhdar Sais. Proc. of ECAI 2004, pages 146-150. Valencia, Spain, 2004.</p>
<p>See : <em> Last Conflict Based Reasoning </em>. Christophe Lecoutre, Lakhdar Sais, Sebastien Tabary, Vincent Vidal. Proc. of ECAI 2006, pages 133-137. Trentino, Italy, 2006.</p>
<p>See : <em> Solution-based phase saving for CP: A value-selection heuristic to simulate local search behavior in complete solvers </em>. Emir Demirovic, Geoffrey Chu, and Peter Stuckey. Proc. of CP-18, pages 99–108. Lille, France, 2018. </p>
</dd></dl>

</section>
<section id="soft-arc-consistency-and-problem-reformulation">
<h2>Soft arc consistency and problem reformulation<a class="headerlink" href="#soft-arc-consistency-and-problem-reformulation" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__softac"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Soft</span> <span class="pre">arc</span> <span class="pre">consistency</span> <span class="pre">and</span> <span class="pre">problem</span> <span class="pre">reformulation</span></span></dt>
<dd><p>Soft arc consistency is an incremental lower bound technique for optimization problems. Its goal is to move costs from high-order (typically arity two or three) cost functions towards the problem lower bound and unary cost functions. This is achieved by applying iteratively local equivalence-preserving problem transformations (EPTs) until some terminating conditions are met.</p>
<p>Note : <em>eg</em> an EPT can move costs between a binary cost function and a unary cost function such that the sum of the two functions remains the same for any complete assignment.</p>
<p>See : <em> Arc consistency for Soft Constraints. </em> T. Schiex. Proc. of CP’2000. Singapour, 2000.</p>
<p>Note : Soft Arc Consistency in toulbar2 is limited to binary and ternary and some global cost functions (<em>eg</em> alldifferent, gcc, regular, same). Other n-ary cost functions are delayed for propagation until their number of unassigned variables is three or less.</p>
<p>See : <em> Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction. </em> Jimmy Ho-Man Lee, Ka Lun Leung. Proc. of IJCAI 2009, pages 559-565. Pasadena, USA, 2009. </p>
</dd></dl>

</section>
<section id="virtual-arc-consistency-enforcing">
<h2>Virtual Arc Consistency enforcing<a class="headerlink" href="#virtual-arc-consistency-enforcing" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__VAC"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Virtual</span> <span class="pre">Arc</span> <span class="pre">Consistency</span> <span class="pre">enforcing</span></span></dt>
<dd><p>The three phases of VAC are enforced in three different “Pass”. Bool(P) is never built. Instead specific functions (getVACCost) booleanize the WCSP on the fly. The domain variables of Bool(P) are the original variable domains (saved and restored using trailing at each iteration). All the counter data-structures (k) are timestamped to avoid clearing them at each iteration.</p>
<p>Note: Simultaneously AC (and potentially DAC, EAC) are maintained by proper queuing.</p>
<p>Note: usual domain events such that assign/remove should not be called during VAC phase 1, use removeVAC instead.</p>
<p>See : <em> Soft Arc Consistency Revisited. </em> Cooper et al. Artificial Intelligence. 2010. </p>
</dd></dl>

</section>
<section id="nc-bucket-sort">
<h2>NC bucket sort<a class="headerlink" href="#nc-bucket-sort" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__ncbucket"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">NC</span> <span class="pre">bucket</span> <span class="pre">sort</span></span></dt>
<dd><p>maintains a sorted list of variables having non-zero unary costs in order to make NC propagation incremental.<ul class="simple">
<li><p>variables are sorted into buckets</p></li>
<li><p>each bucket is associated to a single interval of non-zero costs (using a power-of-two scaling, first bucket interval is [1,2[, second interval is [2,4[, etc.)</p></li>
<li><p>each variable is inserted into the bucket corresponding to its largest unary cost in its domain</p></li>
<li><p>variables having all unary costs equal to zero do not belong to any bucket</p></li>
</ul>
</p>
<p>NC propagation will revise only variables in the buckets associated to costs sufficiently large wrt current objective bounds. </p>
</dd></dl>

</section>
<section id="variable-elimination">
<h2>Variable elimination<a class="headerlink" href="#variable-elimination" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__varelim"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Variable</span> <span class="pre">elimination</span></span></dt>
<dd><p><ul class="simple">
<li><p><em>i-bounded</em> variable elimination eliminates all variables with a degree less than or equal to <em>i</em>. It can be done with arbitrary i-bound in preprocessing only and iff all their cost functions are in extension.</p></li>
<li><p><em>i-bounded</em> variable elimination with i-bound less than or equal to two can be done during the search.</p></li>
<li><p>functional variable elimination eliminates all variables which have a bijective or functional binary hard constraint (<em>ie</em> ensuring a one-to-one or several-to-one value mapping) and iff all their cost functions are in extension. It can be done without limit on their degree, in preprocessing only.</p></li>
</ul>
</p>
<p>Note : Variable elimination order used in preprocessing is either lexicographic or given by an external file *.order (see toulbar2 options)</p>
<p>Note : 2-bounded variable elimination during search is optimal in the sense that any elimination order should result in the same final graph</p>
<p>Warning : It is not possible to display/save solutions when bounded variable elimination is applied in preprocessing</p>
<p>Warning : toulbar2 maintains a list of current cost functions for each variable. It uses the size of these lists as an approximation of variable degrees. During the search, if variable <em>x</em> has three cost functions <em>xy</em>, <em>xz</em>, <em>xyz</em>, its true degree is two but its approximate degree is three. In toulbar2 options, it is the approximate degree which is given by the user for variable elimination during the search (thus, a value at most three). But it is the true degree which is given by the user for variable elimination in preprocessing. </p>
</dd></dl>

</section>
<section id="propagation-loop">
<h2>Propagation loop<a class="headerlink" href="#propagation-loop" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__propagation"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Propagation</span> <span class="pre">loop</span></span></dt>
<dd><p><p>Propagates soft local consistencies and bounded variable elimination until all the propagation queues are empty or a contradiction occurs.</p>
<p>While (queues are not empty or current objective bounds have changed):</p>
<ol class="arabic simple">
<li><p>queue for bounded variable elimination of degree at most two (except at preprocessing)</p></li>
<li><p>BAC queue</p></li>
<li><p>EAC queue</p></li>
<li><p>DAC queue</p></li>
<li><p>AC queue</p></li>
<li><p>monolithic (flow-based and DAG-based) global cost function propagation (partly incremental)</p></li>
<li><p>NC queue</p></li>
<li><p>returns to #1 until all the previous queues are empty</p></li>
<li><p>DEE queue</p></li>
<li><p>returns to #1 until all the previous queues are empty</p></li>
<li><p>VAC propagation (not incremental)</p></li>
<li><p>returns to #1 until all the previous queues are empty (and problem is VAC if enable)</p></li>
<li><p>exploits goods in pending separators for BTD-like methods</p></li>
</ol>
</p>
<p>Queues are first-in / first-out lists of variables (avoiding multiple insertions). In case of a contradiction, queues are explicitly emptied by WCSP::whenContradiction </p>
</dd></dl>

</section>
<section id="backtrack-management">
<h2>Backtrack management<a class="headerlink" href="#backtrack-management" title="Link to this heading"></a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__backtrack"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">Backtrack</span> <span class="pre">management</span></span></dt>
<dd><p>Used by backtrack search methods. Allows to copy / restore the current state using Store::store and Store::restore methods. All storable data modifications are trailed into specific stacks.</p>
<p>Trailing stacks are associated to each storable type:<ul class="simple">
<li><p>Store::storeValue for storable domain values ::StoreValue (value supports, etc)</p></li>
<li><p>Store::storeInt for storable integer values ::StoreInt (number of non assigned variables in nary cost functions, etc)</p></li>
<li><p>Store::storeCost for storable costs ::StoreCost (inside cost functions, etc)</p></li>
<li><p>Store::storeDomain for enumerated domains (to manage holes inside domains)</p></li>
<li><p>Store::storeIndexList for integer lists (to manage edge connections in global cost functions)</p></li>
<li><p>Store::storeConstraint for backtrackable lists of constraints</p></li>
<li><p>Store::storeVariable for backtrackable lists of variables</p></li>
<li><p>Store::storeSeparator for backtrackable lists of separators (see tree decomposition methods)</p></li>
<li><p>Store::storeKnapsack for backtrackable lists of knapsack constraints</p></li>
<li><p>Store::storeBigInteger for very large integers ::StoreBigInteger used in solution counting methods</p></li>
</ul>
</p>
<p>Memory for each stack is dynamically allocated by part of <span class="math notranslate nohighlight">\(2^x\)</span> with <em>x</em> initialized to ::STORE_SIZE and increased when needed.</p>
<p>Note : storable data are not trailed at depth 0.</p>
<p>Warning : Current storable data management is not multi-threading safe! (Store is a static virtual class relying on StoreBasic&lt;T&gt; static members) </p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../_files/README.html" class="btn btn-neutral float-left" title="Exact optimization for cost function networks and additive graphical models" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ref_lib.html" class="btn btn-neutral float-right" title="Libraries" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, INRAE.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
        News system by <a href="https://giscus.app">giscus</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>